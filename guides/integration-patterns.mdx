---
title: "Integration Patterns"
description: "Common patterns for integrating HANA into your healthcare workflows — from simple triggers to complex multi-step orchestrations."
---

## Pattern 1: EHR-Triggered Engagement

The most common pattern. An event in your EHR triggers a HANA engagement automatically.

**Use case:** Patient is discharged → HANA calls them Day 1, Day 3, Day 7 for post-discharge monitoring.

```javascript
// Your EHR fires a webhook when patient is discharged
app.post('/ehr/discharge', async (req, res) => {
  const { patientId, dischargeDate, surgeryType } = req.body;
  
  // Schedule post-discharge check-in series
  const schedule = [
    { day: 1, protocol: 'post-discharge-day1' },
    { day: 3, protocol: 'post-discharge-day3' },
    { day: 7, protocol: 'post-discharge-day7' }
  ];
  
  for (const s of schedule) {
    const scheduledAt = addDays(dischargeDate, s.day);
    await hana.engagements.create({
      patient: { id: patientId },
      protocol: s.protocol,
      triggerType: 'scheduled',
      scheduledAt: scheduledAt.toISOString(),
      context: {
        ehrData: { surgeryType, dischargeDate }
      }
    });
  }
  
  res.status(200).send('ok');
});
```

---

## Pattern 2: Alert-Driven Follow-Up

A wearable or RPM device generates an alert. HANA calls the patient to gather context before escalating to the care team.

**Use case:** Heart rate spike detected → HANA calls patient → "Were you exercising or is something wrong?" → Route appropriately.

```javascript
// RPM platform fires alert
app.post('/rpm/alert', async (req, res) => {
  const { patientId, alertType, value, threshold } = req.body;
  
  await hana.engagements.create({
    patient: { id: patientId },
    protocol: 'rpm-alert-followup',
    triggerType: 'immediate', // Call now
    context: {
      recentEvents: [{
        type: alertType,
        value: value,
        threshold: threshold,
        timestamp: new Date().toISOString()
      }]
    }
  });
  
  res.status(200).send('ok');
});

// HANA calls patient, gathers context, then sends webhook
app.post('/webhooks/hana', (req, res) => {
  const event = req.body;
  
  if (event.event === 'engagement.completed') {
    const { risk_level, clinical_note } = event.data.outcome;
    
    if (risk_level === 'high' || risk_level === 'critical') {
      // Route to care team immediately
      alertCareTeam(event.data.patient_id, clinical_note);
    } else {
      // Log as resolved — patient was exercising
      logResolvedAlert(event.data.patient_id, clinical_note);
    }
  }
  
  res.status(200).send('ok');
});
```

---

## Pattern 3: Batch Enrollment

Enroll an entire patient panel into a care program at once.

**Use case:** Clinic adopts CCM program → Enroll 500 eligible patients → Weekly HANA check-ins begin.

```javascript
// Batch enroll patients from EHR export
const patients = await loadPatientRoster('./eligible-ccm-patients.csv');

for (const patient of patients) {
  // Register patient with HANA
  await hana.patients.upsert(patient.id, {
    firstName: patient.firstName,
    lastName: patient.lastName,
    phone: patient.phone,
    preferredLanguage: patient.language,
    clinicalData: {
      diagnoses: patient.diagnoses,
      medications: patient.medications
    },
    tags: ['ccm_enrolled']
  });
  
  // Schedule first engagement
  await hana.engagements.create({
    patient: { id: patient.id },
    protocol: 'ccm-weekly-checkin',
    triggerType: 'scheduled',
    scheduledAt: nextMonday10am().toISOString()
  });
}
```

---

## Pattern 4: Platform Embedding (HANA Connect)

Your product triggers HANA engagements on behalf of your customers. Each customer gets white-labeled experience.

**Use case:** Care management platform → Clinic A and Clinic B both use your platform → Each gets their own branding on HANA calls.

```javascript
// When a new clinic signs up on your platform
async function onboardClinic(clinic) {
  // Create HANA sub-org for this clinic
  const org = await hana.organizations.create({
    name: clinic.name,
    config: {
      protocols: ['medication-adherence', 'post-visit-followup'],
      timezone: clinic.timezone
    },
    whiteLabel: {
      callerName: clinic.name,
      callerId: clinic.phone
    }
  });
  
  // Store org ID
  await db.clinics.update(clinic.id, { hanaOrgId: org.id });
}

// When scheduling engagement for a clinic's patient
async function scheduleCheckIn(clinicId, patientId) {
  const clinic = await db.clinics.get(clinicId);
  
  await hana.engagements.create({
    organizationId: clinic.hanaOrgId, // Scoped to clinic
    patient: { id: patientId },
    protocol: 'medication-adherence',
    triggerType: 'scheduled',
    scheduledAt: '2026-02-08T10:00:00Z'
  });
}
```

---

## Pattern 5: Continuous Monitoring Loop

For chronic care — ongoing engagement that adapts based on patient responses over time.

**Use case:** Diabetes patient → Weekly check-in → If adherence drops, increase frequency → If stable for 4 weeks, decrease.

```javascript
// Process completed engagement and schedule next
app.post('/webhooks/hana', async (req, res) => {
  const event = req.body;
  
  if (event.event === 'engagement.completed') {
    const { patient_id, outcome } = event.data;
    const adherence = outcome.clinical_note.structured.medication_adherence;
    
    // Adaptive scheduling based on adherence
    let nextInterval;
    if (adherence < 0.5) {
      nextInterval = 3;   // Check in 3 days
    } else if (adherence < 0.7) {
      nextInterval = 5;   // Check in 5 days
    } else {
      nextInterval = 7;   // Standard weekly
    }
    
    // Schedule next engagement
    await hana.engagements.create({
      patient: { id: patient_id },
      protocol: 'medication-adherence-diabetes',
      triggerType: 'scheduled',
      scheduledAt: addDays(new Date(), nextInterval).toISOString()
    });
  }
  
  res.status(200).send('ok');
});
```

<Note>
HANA's reasoning engine handles much of this adaptive logic internally. This pattern is useful when your application needs to control the scheduling logic explicitly.
</Note>

---

## Pattern 6: Clinical Note Pipeline

Route HANA's clinical notes into your documentation system or EHR.

```javascript
app.post('/webhooks/hana', async (req, res) => {
  const event = req.body;
  
  if (event.event === 'clinical_note.ready') {
    const { patient_id, clinical_note } = event.data;
    
    // Write to EHR via FHIR
    await fhirClient.create({
      resourceType: 'DocumentReference',
      status: 'current',
      subject: { reference: `Patient/${patient_id}` },
      content: [{
        attachment: {
          contentType: 'text/plain',
          data: Buffer.from(clinical_note.narrative).toString('base64')
        }
      }]
    });
    
    // Create task if needed
    for (const task of event.data.tasks) {
      await taskQueue.push({
        patientId: patient_id,
        type: task.type,
        priority: task.priority,
        reason: task.reason
      });
    }
  }
  
  res.status(200).send('ok');
});
```

---

## Anti-Patterns

Things to avoid when integrating HANA:

| Don't | Do Instead |
|-------|-----------|
| Poll for engagement status | Use webhooks — HANA pushes results to you |
| Store API keys in client-side code | Use environment variables or a secrets manager |
| Create engagements without patient context | Always pass EHR data — richer context = better conversations |
| Ignore escalation events | Set up alerting for `engagement.escalated` — these need human attention |
| Skip sandbox testing | Test end-to-end in sandbox before any production deployment |

<Card title="Back to Quickstart" icon="rocket" href="/developers/quickstart">
  Start your integration from scratch.
</Card>
